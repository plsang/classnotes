%% This file was auto-generated by IPython.
%% Conversion from the original notebook file:
%% ratings.ipynb
%%
\documentclass[11pt,english,fleqn]{article}

%% This is the automatic preamble used by IPython.  Note that it does *not*
%% include a documentclass declaration, that is added at runtime to the overall
%% document.

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{ucs}
\usepackage[utf8x]{inputenc}

% needed for markdown enumerations to work
\usepackage{enumerate}

% Slightly bigger margins than the latex defaults
\usepackage{geometry}
\geometry{verbose,tmargin=3cm,bmargin=3cm,lmargin=2.5cm,rmargin=2.5cm}

% Define a few colors for use in code, links and cell shading
\usepackage{color}
\definecolor{orange}{cmyk}{0,0.4,0.8,0.2}
\definecolor{darkorange}{rgb}{.71,0.21,0.01}
\definecolor{darkgreen}{rgb}{.12,.54,.11}
\definecolor{myteal}{rgb}{.26, .44, .56}
\definecolor{gray}{gray}{0.45}
\definecolor{lightgray}{gray}{.95}
\definecolor{mediumgray}{gray}{.8}
\definecolor{inputbackground}{rgb}{.95, .95, .85}
\definecolor{outputbackground}{rgb}{.95, .95, .95}
\definecolor{traceback}{rgb}{1, .95, .95}

% Framed environments for code cells (inputs, outputs, errors, ...).  The
% various uses of \unskip (or not) at the end were fine-tuned by hand, so don't
% randomly change them unless you're sure of the effect it will have.
\usepackage{framed}

% remove extraneous vertical space in boxes
\setlength\fboxsep{0pt}

% codecell is the whole input+output set of blocks that a Code cell can
% generate.

% TODO: unfortunately, it seems that using a framed codecell environment breaks
% the ability of the frames inside of it to be broken across pages.  This
% causes at least the problem of having lots of empty space at the bottom of
% pages as new frames are moved to the next page, and if a single frame is too
% long to fit on a page, will completely stop latex from compiling the
% document.  So unless we figure out a solution to this, we'll have to instead
% leave the codecell env. as empty.  I'm keeping the original codecell
% definition here (a thin vertical bar) for reference, in case we find a
% solution to the page break issue.

%% \newenvironment{codecell}{%
%%     \def\FrameCommand{\color{mediumgray} \vrule width 1pt \hspace{5pt}}%
%%    \MakeFramed{\vspace{-0.5em}}}
%%  {\unskip\endMakeFramed}

% For now, make this a no-op...
\newenvironment{codecell}{}

 \newenvironment{codeinput}{%
   \def\FrameCommand{\colorbox{inputbackground}}%
   \MakeFramed{\advance\hsize-\width \FrameRestore}}
 {\unskip\endMakeFramed}

\newenvironment{codeoutput}{%
   \def\FrameCommand{\colorbox{outputbackground}}%
   \vspace{-1.4em}
   \MakeFramed{\advance\hsize-\width \FrameRestore}}
 {\unskip\medskip\endMakeFramed}

\newenvironment{traceback}{%
   \def\FrameCommand{\colorbox{traceback}}%
   \MakeFramed{\advance\hsize-\width \FrameRestore}}
 {\endMakeFramed}

% Use and configure listings package for nicely formatted code
\usepackage{listingsutf8}
\lstset{
  language=python,
  inputencoding=utf8x,
  extendedchars=\true,
  aboveskip=\smallskipamount,
  belowskip=\smallskipamount,
  xleftmargin=2mm,
  breaklines=true,
  basicstyle=\small \ttfamily,
  showstringspaces=false,
  keywordstyle=\color{blue}\bfseries,
  commentstyle=\color{myteal},
  stringstyle=\color{darkgreen},
  identifierstyle=\color{darkorange},
  columns=fullflexible,  % tighter character kerning, like verb
}

% The hyperref package gives us a pdf with properly built
% internal navigation ('pdf bookmarks' for the table of contents,
% internal cross-reference links, web links for URLs, etc.)
\usepackage{hyperref}
\hypersetup{
  breaklinks=true,  % so long urls are correctly broken across lines
  colorlinks=true,
  urlcolor=blue,
  linkcolor=darkorange,
  citecolor=darkgreen,
  }

% hardcode size of all verbatim environments to be a bit smaller
\makeatletter 
\g@addto@macro\@verbatim\small\topsep=0.5em\partopsep=0pt
\makeatother 

% Prevent overflowing lines due to urls and other hard-to-break entities.
\sloppy

\setlength{\mathindent}{0pt}
\setlength{\parindent}{0pt}
\setlength{\parskip}{8pt}
\begin{document}

Pivotlama

Ornek olarak film isimleri ve o filmlere verilmis begeni notlarini
tasiyan bir veri tabanini isleyecegiz. Verimiz uc ayri dosyaya yayilmis
halde. Uc tabloyu alttaki sekilde, merge komutu ile birlestiriyoruz -
Pandas otomatik olarak ortak kolon ismini bulacak ve onun uzerinden
birlestirimi yapacak.

\begin{codecell}
\begin{codeinput}
\begin{lstlisting}
import pandas as pd
unames = ['user_id', 'gender', 'age', 'occupation', 'zip']
users = pd.read_table('users.dat', sep='::', header=None,names=unames)
rnames = ['user_id', 'movie_id', 'rating', 'timestamp']
ratings = pd.read_table('ratings.dat', sep='::', header=None,names=rnames)
mnames = ['movie_id', 'title', 'genres']
movies = pd.read_table('movies.dat', sep='::', header=None,names=mnames)
data = pd.merge(pd.merge(ratings, users), movies)
\end{lstlisting}
\end{codeinput}
\end{codecell}
\begin{codecell}
\begin{codeinput}
\begin{lstlisting}
data
\end{lstlisting}
\end{codeinput}
\begin{codeoutput}
\begin{verbatim}
<class 'pandas.core.frame.DataFrame'>
Int64Index: 1000209 entries, 0 to 1000208
Data columns:
user_id       1000209  non-null values
movie_id      1000209  non-null values
rating        1000209  non-null values
timestamp     1000209  non-null values
gender        1000209  non-null values
age           1000209  non-null values
occupation    1000209  non-null values
zip           1000209  non-null values
title         1000209  non-null values
genres        1000209  non-null values
dtypes: int64(6), object(4)
\end{verbatim}
\end{codeoutput}
\end{codecell}
Eger erkeklerin en cok sevdigi ama kadinlarin en az sevdigi (ve hanimlar
icin tam tersi olan) filmleri bulmak istiyorsak, bu islemi nasil
yapariz? Bu islemi Pandas ile yapmak icin ilginc bir takla atacagiz.
``Bir grubun en cok digerinin en az'' sorusu, onlarin bir filme verdigi
ortalama notun farkinin en buyuk olmasi demektir. Bunu dusunebilmek
onemli.

Ikinci olarak bu islemin kodlamasi icin ne gerekir? Bir cikartma islemi
lazim. Ideal olarak bir kolonu (ya da satiri) digerinden cikartmak - bu
tur toptan islemler zaten Pandas ile cok hizli.

Fakat verimiz halen o formatta degil. Her satir, tek bir film, tek bir
kisi (cinsiyet) ve tek bir not icin kaydedilmis. Bizim ilgilendigimiz
analiz icin biz film bazinda icin cinsiyet verisini \emph{yanyana,
degisik kolonlarda} gormeliyiz.

Peki nasil? Cevap pivotlamak.

Pivotlamak bir kolonu (hatta birkac kolonu) alip onu x ekseni yapmak,
ayni sekilde bir (veya birkac) kolonu y ekseni yapmak anlamina gelir.
Yani bir kolon uzerindeki tum degerler okunur, ve kordinatmis gibi o
eksene yayilir. Ayni sekilde diger kordinat halledilir. Daha sonra bu
iki kordinattaki kesisim degerleri icin bir ucuncu numerik kolon secilir
(ve onun uzerinden ek bir numerik islem de tanimlanabilir), ve boylece
pivotlama gerceklesmis olur.

Bizim pivot icin cinsiyet kolona yayilacak, film ismi satira yayilacak.
Kesisim ise not ortalamasi (rating mean) olacak.

\begin{codecell}
\begin{codeinput}
\begin{lstlisting}
mean_ratings = data.pivot_table('rating', rows='title', cols='gender',
                                aggfunc='mean')
mean_ratings[:5]
\end{lstlisting}
\end{codeinput}
\begin{codeoutput}
\begin{verbatim}
gender                                F         M
title                                            
$1,000,000 Duck (1971)         3.375000  2.761905
'Night Mother (1986)           3.388889  3.352941
'Til There Was You (1997)      2.675676  2.733333
'burbs, The (1989)             2.793478  2.962085
...And Justice for All (1979)  3.828571  3.689024
\end{verbatim}
\end{codeoutput}
\end{codecell}
Daha fazla ilerlemeden ufak bir ek islem daha yapalim, 250'den daha az
not almis olan filmleri eleyelim.

\begin{codecell}
\begin{codeinput}
\begin{lstlisting}
ratings_by_title = data.groupby('title').size()
active_titles = ratings_by_title.index[ratings_by_title >= 250]
active_titles[:10]

\end{lstlisting}
\end{codeinput}
\begin{codeoutput}
\begin{verbatim}
Index(['burbs, The (1989), 10 Things I Hate About You (1999), 101 Dalmatians (1961), 101 Dalmatians (1996), 12 Angry Men (1957), 13th Warrior, The (1999), 2 Days in the Valley (1996), 20,000 Leagues Under the Sea (1954), 2001: A Space Odyssey (1968), 2010 (1984)], dtype=object)
\end{verbatim}
\end{codeoutput}
\end{codecell}
Yapilan harekete dikkat: ratings\_by\_title.index uzerinde bir boolean
filtreleme yaptik, yani {[}True, False\ldots{}, True{]} gibi bir
filtreleyiciyi Index \textbf{objesi} uzerinde kullandik. Bu niye isledi?
Cunku .index cagrisi da sonucta bir dizindir, ve dizinler uzerinde
istenen boolean filtrelemesi yapilabilir (her iki taraf ta ayni boyutta
oldugu surece).

Devam edelim, simdi ortalama notlari ustteki yeni Index'e gore azaltalim
(ve .ix kullanacagiz, cunku Index objesi satirlar uzerinde islem yapar
ve .ix cagrisi satirlara erismek icin kullanilir), ve hanimlarin en cok
sevdigi filmlere bakalim,

\begin{codecell}
\begin{codeinput}
\begin{lstlisting}
mean_ratings = mean_ratings.ix[active_titles]
top_female_ratings = mean_ratings.sort_index(by='F', ascending=False)
top_female_ratings[:4]
\end{lstlisting}
\end{codeinput}
\begin{codeoutput}
\begin{verbatim}
gender                                                         F         M  \
title                                                                        
Close Shave, A (1995)                                   4.644444  4.473795   
Wrong Trousers, The (1993)                              4.588235  4.478261   
Sunset Blvd. (a.k.a. Sunset Boulevard) (1950)           4.572650  4.464589   
Wallace & Gromit: The Best of Aardman Animation (1996)  4.563107  4.385075   

gender                                                      diff  
title                                                             
Close Shave, A (1995)                                  -0.170650  
Wrong Trousers, The (1993)                             -0.109974  
Sunset Blvd. (a.k.a. Sunset Boulevard) (1950)          -0.108060  
Wallace & Gromit: The Best of Aardman Animation (1996) -0.178032  
\end{verbatim}
\end{codeoutput}
\end{codecell}
Baylara pek tanidik gelmeyen bir liste. Simdi erkekler ve hanimlar
begeni farkini hesaplayalim ve en buyuk farklar en ustte olacak sekilde
siralama (sort) yapalim,

\begin{codecell}
\begin{codeinput}
\begin{lstlisting}
mean_ratings['diff'] = mean_ratings['M'] - mean_ratings['F']
sorted_by_diff = mean_ratings.sort_index(by='diff')
sorted_by_diff[:6]		
\end{lstlisting}
\end{codeinput}
\begin{codeoutput}
\begin{verbatim}
gender                            F         M      diff
title                                                  
Dirty Dancing (1987)       3.790378  2.959596 -0.830782
Jumpin' Jack Flash (1986)  3.254717  2.578358 -0.676359
Grease (1978)              3.975265  3.367041 -0.608224
Little Women (1994)        3.870588  3.321739 -0.548849
Steel Magnolias (1989)     3.901734  3.365957 -0.535777
Anastasia (1997)           3.800000  3.281609 -0.518391
\end{verbatim}
\end{codeoutput}
\end{codecell}
\emph{Dirty Dancing}, \emph{Grease} gibi romantik filmler ustte cikti.
Simdi listeyi ters cevirelim ve en alta bakalim, orada baylarin en cok
hanimlarin en az sevdigi filmler olmali,

\begin{codecell}
\begin{codeinput}
\begin{lstlisting}
sorted_by_diff[::-1][:15]
\end{lstlisting}
\end{codeinput}
\begin{codeoutput}
\begin{verbatim}
gender                                         F         M      diff
title                                                               
Good, The Bad and The Ugly, The (1966)  3.494949  4.221300  0.726351
Kentucky Fried Movie, The (1977)        2.878788  3.555147  0.676359
Dumb & Dumber (1994)                    2.697987  3.336595  0.638608
Longest Day, The (1962)                 3.411765  4.031447  0.619682
Cable Guy, The (1996)                   2.250000  2.863787  0.613787
Evil Dead II (Dead By Dawn) (1987)      3.297297  3.909283  0.611985
Hidden, The (1987)                      3.137931  3.745098  0.607167
Rocky III (1982)                        2.361702  2.943503  0.581801
Caddyshack (1980)                       3.396135  3.969737  0.573602
For a Few Dollars More (1965)           3.409091  3.953795  0.544704
Porky's (1981)                          2.296875  2.836364  0.539489
Animal House (1978)                     3.628906  4.167192  0.538286
Exorcist, The (1973)                    3.537634  4.067239  0.529605
Fright Night (1985)                     2.973684  3.500000  0.526316
Barb Wire (1996)                        1.585366  2.100386  0.515020
\end{verbatim}
\end{codeoutput}
\end{codecell}
Burada da \emph{Good, The Bad and The Ugly} gibi kovboy filmleri, ve
buna benzer vurdulu kirdili filmler ya da enseye tokat turunden
\emph{Aptal ve Daha Aptal (Dumb \& Dumber)} gibi filmler cikti. Ilginc
bir analiz oldu. :)

Burada takip edilen mantiga, ve onun nasil Pandas islemlerina
cevirildigine dikkat. ``X grubunun en cok ama Y grubunun en az'' turunde
bir sorgu bir aritmetik fark hesabina cevrildi ve bir grup icin onemli
olan kalemlerin en ustte, digeri icin en onemli olanin en altta olacagi
akil edildi (en altta eksi degerler vardi tabii ki, bunun sebebini iyi
dusunelim) ve sonuca varildi.

Yapay Ogrenim engin bir alandir, ama regresyon, siniflama gibi
islemlerden once hala yapilabilecek ilginc ve onemli, ustteki gibi veri
analizler var.

Kaynak

McKinney, W., Python for Data Analysis

\end{document}
