%% This file was auto-generated by IPython.
%% Conversion from the original notebook file:
%% matmult.ipynb
%%
\documentclass[11pt,english,fleqn]{article}

%% This is the automatic preamble used by IPython.  Note that it does *not*
%% include a documentclass declaration, that is added at runtime to the overall
%% document.

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{ucs}
\usepackage[utf8x]{inputenc}

% needed for markdown enumerations to work
\usepackage{enumerate}

% Slightly bigger margins than the latex defaults
\usepackage{geometry}
\geometry{verbose,tmargin=3cm,bmargin=3cm,lmargin=2.5cm,rmargin=2.5cm}

% Define a few colors for use in code, links and cell shading
\usepackage{color}
\definecolor{orange}{cmyk}{0,0.4,0.8,0.2}
\definecolor{darkorange}{rgb}{.71,0.21,0.01}
\definecolor{darkgreen}{rgb}{.12,.54,.11}
\definecolor{myteal}{rgb}{.26, .44, .56}
\definecolor{gray}{gray}{0.45}
\definecolor{lightgray}{gray}{.95}
\definecolor{mediumgray}{gray}{.8}
\definecolor{inputbackground}{rgb}{.95, .95, .85}
\definecolor{outputbackground}{rgb}{.95, .95, .95}
\definecolor{traceback}{rgb}{1, .95, .95}

% Framed environments for code cells (inputs, outputs, errors, ...).  The
% various uses of \unskip (or not) at the end were fine-tuned by hand, so don't
% randomly change them unless you're sure of the effect it will have.
\usepackage{framed}

% remove extraneous vertical space in boxes
\setlength\fboxsep{0pt}

% codecell is the whole input+output set of blocks that a Code cell can
% generate.

% TODO: unfortunately, it seems that using a framed codecell environment breaks
% the ability of the frames inside of it to be broken across pages.  This
% causes at least the problem of having lots of empty space at the bottom of
% pages as new frames are moved to the next page, and if a single frame is too
% long to fit on a page, will completely stop latex from compiling the
% document.  So unless we figure out a solution to this, we'll have to instead
% leave the codecell env. as empty.  I'm keeping the original codecell
% definition here (a thin vertical bar) for reference, in case we find a
% solution to the page break issue.

%% \newenvironment{codecell}{%
%%     \def\FrameCommand{\color{mediumgray} \vrule width 1pt \hspace{5pt}}%
%%    \MakeFramed{\vspace{-0.5em}}}
%%  {\unskip\endMakeFramed}

% For now, make this a no-op...
\newenvironment{codecell}{}

 \newenvironment{codeinput}{%
   \def\FrameCommand{\colorbox{inputbackground}}%
   \MakeFramed{\advance\hsize-\width \FrameRestore}}
 {\unskip\endMakeFramed}

\newenvironment{codeoutput}{%
   \def\FrameCommand{\colorbox{outputbackground}}%
   \vspace{-1.4em}
   \MakeFramed{\advance\hsize-\width \FrameRestore}}
 {\unskip\medskip\endMakeFramed}

\newenvironment{traceback}{%
   \def\FrameCommand{\colorbox{traceback}}%
   \MakeFramed{\advance\hsize-\width \FrameRestore}}
 {\endMakeFramed}

% Use and configure listings package for nicely formatted code
\usepackage{listingsutf8}
\lstset{
  language=python,
  inputencoding=utf8x,
  extendedchars=\true,
  aboveskip=\smallskipamount,
  belowskip=\smallskipamount,
  xleftmargin=2mm,
  breaklines=true,
  basicstyle=\small \ttfamily,
  showstringspaces=false,
  keywordstyle=\color{blue}\bfseries,
  commentstyle=\color{myteal},
  stringstyle=\color{darkgreen},
  identifierstyle=\color{darkorange},
  columns=fullflexible,  % tighter character kerning, like verb
}

% The hyperref package gives us a pdf with properly built
% internal navigation ('pdf bookmarks' for the table of contents,
% internal cross-reference links, web links for URLs, etc.)
\usepackage{hyperref}
\hypersetup{
  breaklinks=true,  % so long urls are correctly broken across lines
  colorlinks=true,
  urlcolor=blue,
  linkcolor=darkorange,
  citecolor=darkgreen,
  }

% hardcode size of all verbatim environments to be a bit smaller
\makeatletter 
\g@addto@macro\@verbatim\small\topsep=0.5em\partopsep=0pt
\makeatother 

% Prevent overflowing lines due to urls and other hard-to-break entities.
\sloppy

\setlength{\mathindent}{0pt}
\setlength{\parindent}{0pt}
\setlength{\parskip}{8pt}
\begin{document}

\section{Matris Carpimi}

Matrix carpiminin tarifini lise derslerinden hatirlayabiliriz. Sol el
sol taraftaki matriste bir satir boyunca, sag el sagdaki matris uzerinde
kolon boyunca oge oge hareket ettirilir, ve bu hareket sirasindaki
ogeler carpilip, o carpimlar surekli toplanir. Sol ve sag elin bir
hareketi bittiginde, ele gecen tek bir sayi vardir, ve o sayi uzerinden
gecilen satir $i$ ve kolon $j$ icin sonuc matrisi, mesela $C$'nin,
$i$'inci satiri ve $j$'inci kolonuna yazilir.

Daha basit bir $Ax$ ornegine bakarsak, yani solda $A$ ve sagda $x$ var,
carpim
\[
\begin{bmatrix}
1 & 1 & 6 \\
3 & 0 & 1 \\
1 & 1 & 4 \\
\end{bmatrix}
\begin{bmatrix}
2 \\
5 \\
0 \\
\end{bmatrix}
\]
Bu carpimi bir kac sekilde gorebiliriz. Eger ustte tarif edilen gibi
gorduysek,
\[
\begin{bmatrix}
1\cdot 2 + 1\cdot 5 + 6\cdot 0 \\
3\cdot 2 + 0\cdot 1 + 3\cdot 0 \\
1\cdot 2 + 1\cdot 5 + 4\cdot 0 
\end{bmatrix}
=
\begin{bmatrix}
7 \\
6 \\
7 \\
\end{bmatrix}
\]
Fakat matris carpimina bakmanin bir yolu daha var, hatta bu bakis
acisinin daha onemli bile oldugu soylenebilir, o da $A$'nin kolonlarinin
kombine edilerek saga sonuc olarak gecilmesi bakisidir. Buna gore
\[
2\cdot 
\begin{bmatrix}
1 \\
3 \\
1 \\
\end{bmatrix}
+
5\cdot 
\begin{bmatrix}
1 \\
0 \\
1 \\
\end{bmatrix}
+
0\cdot 
\begin{bmatrix}
6 \\
3 \\
4 \\
\end{bmatrix}
=
\begin{bmatrix}
7 \\
6 \\
7 \\
\end{bmatrix}
\]
Tabii burada ikinci ``matris'' aslinda bir vektor, ama o vektor de
matris olsaydi,

\begin{codecell}
\begin{codeinput}
\begin{lstlisting}
A = np.array([[1 ,1 , 6],[3 , 0 , 1],[1 , 1 , 4]])

x = np.array([[2], [5], [0]])

print "vektor ile\n"

print np.dot(A,x)

B = np.array([[2, 2, 2],[5, 5, 5],[0, 0, 0]])

print "\nmatris ile\n"

print np.dot(A,B)

\end{lstlisting}
\end{codeinput}
\begin{codeoutput}
\begin{verbatim}
vektor ile

[[7]
 [6]
 [7]]

matris ile

[[7 7 7]
 [6 6 6]
 [7 7 7]]
\end{verbatim}
\end{codeoutput}
\end{codecell}
Yani bu durumda sagdaki $B$ icindeki her kolonu bir ayri $x$ gibi gorup,
onun olusturdugu carpim sonucunu, sonuc matrisindeki ayri bir kolona
yazilmis gibi dusunebiliriz.

Kaynaklar

{[}1{]} Linear Algebra and Its Applications, 4th Edition, sf. 20-22, G.
Strang

\end{document}
