\begin{minted}[fontsize=\footnotesize]{python}

\begin{minted}[fontsize=\footnotesize]{python}
from pygraph.classes.digraph import digraph
from pygraph.algorithms.minmax import maximum_flow
gr = digraph()
gr.add_nodes([0,1,2,3])
gr.add_edge((0,1),wt=4)
gr.add_edge((1,2),wt=3)
gr.add_edge((2,3),wt=5)
gr.add_edge((0,2),wt=3)
gr.add_edge((1,3),wt=4)

flows,cuts = maximum_flow(gr,0,3)
print 'flow is', flows
\end{minted}

\begin{verbatim}
flow is {(0, 1): 4, (1, 2): 0, (1, 3): 4, (2, 3): 3, (0, 2): 3}
\end{verbatim}

\begin{minted}[fontsize=\footnotesize]{python}
from collections import defaultdict
from itertools import chain
from collections import deque

FF_SIMPLE_GRAPH = {
    's': {'u': 2, 'x': 2},
    'u': {'v': 1},
    'v': {'x': 1, 't': 2},
    'x': {'y': 1},
    'y': {'t': 2},
    't': {}
}
def tr(G):                                      # Transpose (rev. edges of) G
    GT = {}
    for u in G: GT[u] = set()                   # Get all the nodes in there
    for u in G:
        for v in G[u]:
            GT[v].add(u)                        # Add all reverse edges
    return GT


def bfs_aug(G, H, s, t, f):
    P, Q, F = {s: None}, deque([s]), {s: inf}   # Tree, queue, flow label
    def label(inc):                             # Flow increase at v from u?
        if v in P or inc <= 0: return           # Seen? Unreachable? Ignore
        F[v], P[v] = min(F[u], inc), u          # Max flow here? From where?
        Q.append(v)                             # Discovered -- visit later
    while Q:                                    # Discovered, unvisited
        u = Q.popleft()                         # Get one (FIFO)
        if u == t: return P, F[t]               # Reached t? Augmenting path!
        for v in G[u]: label(G[u][v]-f[u,v])    # Label along out-edges
        for v in H[u]: label(f[v,u])            # Label along in-edges
    return None, 0                              # No augmenting path found

def ford_fulkerson(G, s, t, aug=bfs_aug):       # Max flow from s to t
    H, f = tr(G), defaultdict(int)              # Transpose and flow
    while True:                                 # While we can improve things
        P, c = aug(G, H, s, t, f)               # Aug. path and capacity/slack
        if c == 0: return f                     # No augm. path found? Done!
        u = t                                   # Start augmentation
        while u != s:                           # Backtrack to s
            u, v = P[u], u                      # Shift one step
            if v in G[u]: f[u,v] += c           # Forward edge? Add slack
            else:         f[v,u] -= c           # Backward edge? Cancel slack


G = FF_SIMPLE_GRAPH
f = ford_fulkerson(G, 's', 't')
print sorted(f.items())
\end{minted}

\begin{verbatim}
[(('s', 'u'), 1), (('s', 'x'), 1), (('u', 'v'), 1), (('v', 't'), 1), (('v', 'x'), 0), (('x', 'y'), 1), (('y', 't'), 1)]
\end{verbatim}

\end{minted}
