\documentclass[12pt,fleqn]{article}\usepackage{../common}
\begin{document}
Ozdegerler ve Ozvektorler ile Imaj Bolmek, Gruplamak

Sentetik görüþ (machine vision) dalýnda, karþýmýza çýkan en temel
problemlerden biri, pikselleri guruplayarak bir nesneleyi
tanýmlamaktýr. Bildiðimiz gibi, robot gözden gelen sayýsal bilgiler
ýþýðýnda, 3-boyutlu dünya bilgisayar için 2 boyutlu bir dünyaya dönüþür. Bu
dünyada, pikseller arasýndaki baðlantý kaybolmuþtur. Yani, elimizdeki
veriye tarafsýz bir þekilde bakarsak, iki pikselin hangi nesneye ait
olduðunu belirten 'gizli' bir kodlama bulmamýz imkansýzdýr. Ýmgecikler
arasýnda yapmamýz gereken bu baðlantýyý, algoritmalar kullanarak sonradan
yapmaya mecbur kalýyoruz. Yani, insan gözünün aynen yaptýðý gibi.

Ýþte burada, guruplama (clustering) yöntemleri denen bir dizi algoritma ve
'düþünce þekli' yardýmýmýza yetiþiyor. Çok temel bir konu olduðu için,
guruplama hakkýnda bir çok araþtýrmacý harýl harýl yeni yaklaþýmlar bulmak
ile meþguller. Fakat daha hala tek bir kuram diyebileceðimiz 'hep iþleyen'
bir yaklaþým bulunabilmiþ deðil. Her deðiþik ortam için, deðiþik guruplama
yöntemleri kullanýlýyor.

Her yöntemin baþarý miktarý ötekine göre farklý. Burada özetleyeceðim
yöntem, doðrusal cebir ve çizge spektrum (spectrum) analizi yaparak
guruplamayý baþarýyor. Bu kelimelerin anlamlarýný aþaðýda belirtelim.

Doðrusal cebir, matematik derslerinden hatýrlayabileceðimiz gibi, üstü
olmayan bilinmezli denklemleri çözmenin aritmetiði demektir. Yani doðrusal
cebir denklemlerindeki bilinmeyenler, $x$, $y$, $z$ gibi
deðerlerdir. $x^2$, $y^2$ gibi bilinmezlerle bu dalda uðraþýlmaz.

Doðrusal cebir oldukca iyi araþtýrýlmýþ ve kuramlarý yerine oturmuþ bir
matematik dalýdýr. Her ne kadar üniversitelerde analiz (calculus) dersi
kadar önem verilmese de, bilgisayarlarýn daha güçlenmesi ile doðrusal cebir
daha da çok ragbet görür oldu. Doðrusal cebirin bizim icin ilginç olan
tarafý, son zamanlarda çizge kuramý (graph theory) ile kurulan
baðlantýlarýdýr. Yani, doðrusal cebirden bildiðimiz matris kavramýnýn,
çizgeleri çözmek icin kullanýlabilmesinin keþfedilmesi.

Bir sayýsal görüntu ile çizge arasýndaki baðlantý nedir diye merak
edebilirsiniz... Daha sonra, çizge ile matris arasýndaki baðlantý nedir
diye merak edilebilir... Bu iki baðlantýyý teker teker özetleyecegiz.

Daha rahat göz önüne getirebilmek için, aþaðýdaki resme bakabiliriz.

\includegraphics[height=4cm]{adjacency_graph.jpg}

Bu resimde gördüðümüz (b) þeklinde görünen çizge, (a) þeklinde gösterilen
'ekrandaki' nesnelerin birbirine olan alakasýna göre çizilmiþ bir
çizgedir. Yani, (a) da görülen ner nesneyi (b) çizgesi üzerinde bir düðüm
noktasý olarak belirtirsek, o zaman iki nesnenin birbiri ile, herhangi bir
iliþkisi durumunda, iki düðüm arasýnda bir baðlantý kurarýz. Bu iþlemden
sonra elimize gecen çizgeye bitiþiklik çizgesi diyoruz.

Bir çizge düðümler ve bunlarýn arasýndaki baðlantýlardan ibârettir. 

Cebire gelelim. Aynen doðrusal cebir de olduðu gibi, çizge üzerinde
kurulmuþ bir kuram ve yöntem de var. Bu iki konu uzun sure ayrý yollarda
geliþtiler ve râfine edildiler. Fakat yakýn zamanda matematikçiler çizge
problemlerini çözmek için doðrusal cebir kullanmaya baþladýlar. Meselâ
bahsettiðimiz bitiþiklik çizgesini 'bitiþiklik matrisine' çevirirsek,
doðrusal cebirin yontemlerini kullanarak, çizge hakkýnda bazý sonuçlara
varmamýz mümkün oluyor. Bu çok ilginç ve harika bir baðlantý, ve bir takim
yapýcý yan etkileri var.

Bitiþiklik matrisine örnek olarak (c) þekline bakabilirsiniz.

Bu matrisi yaratýrken, her çizge üzerindeki her düðüme bir sayý verdiðimizi
unutmayalým; o zaman bu kodlamaya göre düðüm 1 ve düðüm 3 arasýnda bir
iliþki var ise, matrise bakýp X ekseni = 1, ve Y ekseni = 3 üzerine tekâbül
eden matris deðerinin 1 olarak tanýmlýyoruz.

Arasýnda iliþki olmayan düðümler, matris üzerinde 0 deðeri taþýyorlar.

Ýþte bu matris üzerinde özdeðer, özvektör yöntemleri kullanarak çizge
hakkýnda sonuçlara varmak mümkün oluyor. 

0 ve 1 degerleri yerine yakinligi piksel degerleri arasindaki farka bagli
olarak ta hesaplayabiliriz. 

Gruplamak

Bir imaji nasil gruplara ayirabiliriz? Ekran piksellerini, çizge (graph)
düðümleri olarak gösterebiliriz, sonra bu çizgeyi yakinsallik (affinity)
matrisine çevirebiliriz. Bu matris üzerinde öyle iþlemler yapalým ki,
elimize $Wx$ denen bir vektör geçsin; bu vektörün $1..N$ üyeleri, $1..N$
piksellerinin $x$ gurubuna üyelik katsayýsý olsun. Katýlým deðerleri en
fazla olan vektör (gurup), ekran üzerindeki en büyük nesne demektir!

Matematiksel olarak þöyle bir formül kuralým, sadece temsil etmeye
ugraþýyoruz, yani bir gurup ve içinde olan pikseller arasýnda baðlantý
kurmak istiyoruz. Piksel ve herhangi bir gurup arasýndaki iliþkiyi formül
ile kaðýt üzerine dökmeyi amacliyoruz. Matematik, sayýlar arasýnda alâka
kurma sanatýdýr. Elimizde þimdilik bir algoritma olmasa bile, temsili
olarak bir alâka kurmak mümkün.

$$ \sum_{i=1}^n \sum_{j=1}^n w_{ij}x_ix_j = \mathbf{x}^T\mathbf{Ax} $$

Bu formüle göre, $Wij$, çizge üzerinde gösterilen i ve j düðümu arasýndaki
baðlantý aðýrlýðý olacak. $x$ vektörünün içindeki her deðer, çizgedeki
düðümlerin bu $x$ gurubuna dâhil olma katsayýsý olacak. Formülun sol
tarafýna göre, bu tanýmlarý her i ve j deðeri için yaparak sonuçlarýný
toplamis oluyoruz. 

Dikkat, toplam sonucu tek bir sayi, yani bir skalar. Nelerin birbiri ile
carpildigi optimizasyon icin cok onemli, $i$ ve $j$ arasindaki agirligi,
$i$'nin uyelik agirligi ve $j$'nin uyelik agirligi ile carpiyoruz, bunlari
tum diger kombinasyonlar icin yapiyoruz, ama bu carpimlari
topluyoruz. Carpim daha fazla buyutur, ve maksimizasyon icin bu buyukluk
daha on planda olacaktir.

Ve bu toplâmýn 'en büyük' olduðu yer, görüntü üzerindeki en büyük nesnenin
olduðu yerdir! Yâni elimizde bir matematiksel maksimizasyon problemi var.

Caprimi tekrar kontrol edelim

$$ 
\left[\begin{array}{ccc}
a_1 & a_2 & a_3
\end{array}\right]
\left[\begin{array}{ccc}
b_{11} & b_{12} & b_{13} \\
b_{21} & b_{22} & b_{23} \\
b_{31} & b_{32} & b_{33} 
\end{array}\right]
\left[\begin{array}{c}
c_1 \\
c_2 \\
c_3
\end{array}\right]
 $$

Diyelim ki $i=2$, $j=1$. O zaman $a_2$, $b_{21}$ ve $c_1$'in birbiriyle
carpilmasi gerekir. Hakikaten caprimi elle kontrol edersek bunun oldugunu
gorecegiz. Icinde $a_1 \cdot b_{21}$ caprimini iceren terim, sonra $c_1$
ile caprilacaktir. 

Formülun yazarý, maksimizasyon iþlemine atlamadan once, bir matematiksel
sýnýr daha koymaya mecbur olmuþ. Maksimizasyon problemlerinde, her sayýyý
muazzam büyüklüklere getirerek formül sonucunu sürekli büyütmek mümkün
olabilirdi. Buna bir sýnýr getirmek için, sað tarafta, A'nin yanýna çarpan
olarak x vektörünün norm'u (yani uzunluðu) 1 olsun demiþ. Altta, bu
tanýmýn açýlmýþ halini görüyorsunuz. (Not: X vektörünün norm'u = X'in
devriði çarpý X). Lagrange formulu soyle gosterilebilir:

$$ w^TAw - \lambda (w^Tw - 1) $$

$$ w^TAw - \lambda (w^Tw - 1) = 0$$

$$ \frac{d}{dw} w^TAw - \lambda (w^Tw - 1) = 0 $$

$$ 2Aw - 2\lambda w = 0$$

$$ 2Aw = 2\lambda w $$

$$ Aw = \lambda w $$

Ustteki son formul ozdeger (eigenvalue), ozvektorler (eigenvector)
formuludur.  Rayleigh-Ritz kuramýna göre, yukarýdaki formülün enbuyütülmüþ
x vektörü , A matrisinin en buyuk özdeðerine tekabül eden özvektör
olacaktir! Dügümler birbirine ne kadar iyi baðlýysa, bir gurubun içsel
baglantýsý ve 'gurupluðu' o kadar iyi oluyor.

Bu son formül aþaðýda

$$ \lambda_{n-k} = 
\max\limits_{x \perp x_{\lambda_n} , .... ,  x_{\lambda_{n-k+1}} } 
\mathbf{x}^T\mathbf{Ax}
$$

Ornek

Alttaki imaji gruplarina ayirmaya calisalim. 

\includegraphics[height=4cm]{twoObj.jpg}

\begin{minted}{python}
Img = plt.imread("twoObj.jpg")
n = Img.shape[0]
Img2 = Img.flatten(order='C')
nn = Img2.shape[0]

A = np.zeros((nn,nn))

for i in range(nn):
    for j in range(nn):
        A[i,j]=np.exp(-((Img2[i]-Img2[j])**2))
        
V,D = np.linalg.eig(A)
V = np.real(V)
a = np.real(D[0])

threshold = 0 # filter
a = np.reshape(a, (n,n))
Img[a<threshold] = 255
imsave('eigseg1.png',Img)
\end{minted}

\includegraphics[height=4cm]{eigseg1.png}

Kodda \verb!imread! ile imaji okuduk, elimize 30x30 boyutunda
bir matris gecti. Bu matrisi once ``duzlestirerek'' bir vektor haline 
getirdik, ki bu vektorun elemanlari yeni bir yakinlilik matrisinin
kenarlari olacakti. Sonra bu yeni elemanlarin her birini bir digeri
ile karsilastirark yakinligini hesapladik, bunu piksel degerinin ne
kadar yakin olduguna bakarak karar verdik, \verb!exp! bunun icin
kullanildi. Ayrica yakinlik ve uzaklik kavramini tersine cevrildi,
\verb!exp! icinde eksi olmasi bundan, birbirine "benzer" yani
degerleri birbirine yakin olan piksellerin farklari az olacaktir,
fakat biz bu azligi maksimizasyon problemi icin bir fazlaliga cevirmek
istiyoruz.

Bu noktada A matrisinin ozdegerlerini hesaplattik, ve geriye
\verb!C!, \verb!D! geri geldi. Numpy ozdegerleri ve ona
tekabul eden ozvektorleri buyukluk sirasina dizerek geri getirir, bu
sayede sifirini (ilk) \verb!D!'ye bakarak en buyuk ozdegere
tekabul eden ozvektoru alabildik. Bu vektorun degerleri ise uyeligi en
yuksek olan grubu iceriyordu. Ciplak gozle bakinca bu degerlerin
uyelik icin pozitif, digerleri icin negatif degerler oldugunu anladik,
bu yuzden esik (threshold) degerini sifir olarak tanimladik. Esigin
altinda kalan degerleri grup disi olarak kabul ettik ve o degerlerin
kordinatina 255 piksel degerini atadik, ki ustteki resimde mavi renkli
gozuken pikseller bu degerleri temsil ediyor.

Not: Ustteki kodlama performans olarak biraz yavas olabilir, alternatif
olarak sadece birbirine yakin pikseller arasi ilinti hesaplanarak ortaya
cikacak seyrek (sparse) matris uzerinde seyrek ozvektor hesabi daha hizli
sonuc verebilir.

Kaynaklar

Sarkar ve Boyer makalesi "Deðisimlerin Sayýsal Ölçümünü Özellik
Organizasyonu Kullanarak Yapmak: Özdeðerler ve Özvektörler". (Quantitative
Measures of Change Based on Feature Organization: EigenValues and
EigenVectors)

Forsyth ve Ponce kitabý "Bilgisayar Görüþü, Yeni Yaklaþým (Computer Vision,
A Modern Approach)


\end{document}
